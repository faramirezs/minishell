#ifndef STRUKTS_H
#define STRUKTS_H

typedef struct s_args
{
	int *count;
	char **words;
} t_args;
//This strcuts needs to be emptied after the exec run.

typedef struct s_chart_itr
{
	const char *cursor;
	const char *sentinel1;
} t_char_itr;

/* typedef struct s_token_list
{
	int type;         // Type of the token, e.g., COMMAND, STRING_LITERAL, etc.
	char *value;      // Value of the token, e.g., "echo", "hello"
	struct s_token_list *next; // Pointer to the next token in the linked list
}			t_token_list; */

typedef enum e_target_type
{
	TARGET_FILENAME, 		// 0 - if token_type of the target is word or cmd
	TARGET_PATHNAME, 		// 1 - if token is REL, ABS path (which can end or not with a file)
	TARGET_ENV_PATHNAME,	// 2 - if token is an env_variable (once we have the nodes we check if the env_var is a valid path, like $PATH/file for example)
	TARGET_DELIMITER		// 3 - if redir_type is HEREDOC
} t_target_type;

typedef struct s_redir
{
	struct s_redir *prev; // we need this so that the curr redir can communicate with the previous if a node had more than 1 redir
	int		redir_type;   // Type of redirection (REDIR_IN, REDIR_OUT, APPEND_OUT, hEREDOC)
	int		redir_i; // can be useful when we have more than 1 redirection in a node
	char	*target;		// Target is filename (for input, output and append) or delimiter (for HEREDOC)
	int		target_type;	// can be delimiter for heredoc, for else it can be file name or a valid path to a file (abs, relative or env_var like $PATH)
	int		target_token_type; // We store the target token type so we can use to understand what path is used in TARGET PATH_NAME
	struct s_redir *next; // we need this as a redirection can be followed by other redirections and interact with them

	// this input can be stored after we have the nodes and before/while executing - still nedd to check if good
	char	*exec_path; // the path where we have to execute the redir, comes from target if target_type is path or we assign it by default to home of shell
	char	*exec_file; // the file we have to execute on (or also create in some cases), comes from target, if target type is not word we have to get the last word in path (comes after last /)
	char	*file_input; // we can store everything together and then split in different lines after if input has \n
	char	**split_input; // we can store everything together and then split in different lines after if input has \n
	int flags; // flags that we pass to open(), depends on the redir type
	int fd; // we can store fd here for future use?
	bool close_fd; // Indicates if the fd should be closed after use.

} t_redir;

typedef struct s_args // list of tokens that follow the command token in the node and considered its arguments
{
	struct s_args *prev;   // Pointer to the prev argument in the list (adding it in case it can be useful in the future)
	int arg_type;         //anything that is not a command/builtin token or part of the redirection struct (file, redir type)
	char *arg_value;      // Value of the token (strings.. could it be also expandables and env variables?)
	struct s_args *next;   // Pointer to the next argument in the list
} t_args;

typedef struct s_cmd // the the first token thas is not redirection data (redirection symbol and file name) or pipe is seen by bash as the command of the node
{
	int		cmd_type;         // type of the token given us from the tokenizer, this will help us with execution and error handling (if the command is not an actual command)
	char	*cmd_value;       // what is the value of the commmand (echo, cd, exit, string_value etc)
} t_cmd;

//a node table is a linked list of nodes, we traverse each node as a double linked list.. why?
// we do it so that when we have to execure we can access each node
typedef struct s_node // A node typically has this data: command, command arguments, redirection data (redir symbol and file name) and pipe, a sequence of node commands is called command_list
{
	struct s_node *prev; // prev nodes can help
	t_cmd *cmd_data; // actually we may not need a struct with cmd, just the value might be enough because of the logic wrote in the execution file
	t_redir *redir_data;
	t_args *cmd_args;
	int	node_i;
	int	nodes_total;// every node will store this data so we know how many pipes we have
	struct s_node *next;
	//not sure yet but we have to find a way to handle -n flag
	bool	n_flag; // flag that tells echo not to append a new_line to the echoed args
	int		n_flag_n; // writes how many time -n flag to see if last arg should be -
} t_node;

// IMPORTANT: AN ABSTRACT SYNTAX TREE IS A SEQUENCE OF NODE LISTS THAT ARE LINKED THROUGH EACHOTHER WITH AN OPERATOR(&& or ||) or a DELIMITER (;)
// THEREFORE ONLY IN THE BONUS WE CREATE A REAL ABSTRACT SYNTAX TREE.
// WITHOUT THE BONUS, ANY OF OUR COMMANDS ARE GROUPED IN NODE COMMANDS IN A SINGLE NODE TABLE: so we do not need to return the ast struct written below.
/* typedef	struct s_ast // wrote this just to better clarify my node structure
{
	t_node			*curr_node_list; // the cmd table made of nodes and pipes
	t_operator		*operator_data; // the && and || operators and ; // the ; delimeter (contais the operator type and value and node to the next cmd table)
	t_node			*next_node_list; // the cmd table made of nodes and pipes
}	t_ast; // without bonus  t_ast will only return 1 cmd_line while the rest of the data is empty */

typedef struct s_token_list
{
	t_token_type type;         // just type,  Type of the token, e.g., COMMAND, STRING_LITERAL, etc.
	char *value;      // just value, Value of the token, e.g., "echo", "hello"
	struct s_token_list *next; // Just next, Pointer to the next token in the linked list
} t_token_list;

typedef enum e_token_type // good to have an order like below
{
	COMMAND,        		// 0 These are the commands we need to create ("echo, cd, pwd, export, unset, env, exit")
	ENV_VAR,        		// 1 Environment variable are words that start with $ (e.g., "$HOME", "$USER"), we do error handling for this after the tokenizing and node creation
	ABS_PATH,           	// 2 A path starting with / (e.g., /directory/directory/  or /directory/file ) is an absolute path and refers to the exact location of the file or command file system staring from root directory
	REL_PATH,           	// 3 A path that doesnâ€™t start with ./ or ../ It is relative to the current working directory. (example ./directory/directory/  or ../directory/directory/  or ../directory/directory/ or ../directory/file )
	OPTION,         		// 4 Command options (only "-n" with echo needs to handled), if not "-n" it should be UKNOWN (unless if the -n is bwtween quotes i think)

	REDIR_IN,       		// 5 Input redirection ("<")
	REDIR_OUT,      		// 6 Output redirection (">")
	APPEND_OUT,     		// 7 Append redirection (">>")
	HEREDOC,        		// 8 Here-document redirection ("<<")

	PIPE,           		// 9 Pipe operator ("|")
	STRING_D_QUOTES,        // 10 Strings inside double quotes (e.g., "hello world"), after the string is ready we have to add a function that will see if we have $var inside here because it can be expanded inside double quotes only, we should also have a function that cheks if there is a command token type only inside
	STRING_S_QUOTES,        // 11 String inside single quotes (e.g., "hello world"), after the string is ready we should have a function that cheks if there is a command token type only inside

	WORD,         			// 12 Any letter or number that is not surrounded in " " and '', after we create the tokens and nodes, we need a function that will see if the word is an external command or just a word
	UNKNOWN,         		// 13 An invalid token type is a symbol that our shell won't have to execute: "\", ";", "&&", "||", unclosed " and ', "(", ")", "#", "&", "$(...)", backticks, "*", "~" etc.. --- what about tilde?
	END,					// 14 END token


	// I DON'T THINK WE NEED THESE ESPECIALLY BECAUSE THESE DETAILS ARE PART OF THE INVALID TOKENS CATEGORY OR THINGS WE WILL CHECK AFTER WE PARSE TOKENS TO NODES
	//EXTERNAL_COMMAND      // commands like grp or ls that we do not have to create, we can access these as binaries in /bin or /usr/bin, we do not need to create tokens for these, after we create our tokens and nodes we will then see if word is a external command
	// D_QUOTE,         	// we can handle unclosed quotes as an unknown token, we can tokenize closed double quotes strings as STRING_D_QUOTES
	// S_QUOTE,         	// we can handle unclosed quotes as an unknown token, we can tokenize closed double quotes strings as STRING_D_QUOTES
	// DELIMITER,      		// we don't hav  to handle ; as a delimiter as it is required by the bonus, the symbol ; be seen as error if not inside a string
	// OPERATOR,       		// we don't hav  to handle logical operators for && and || as they are required by the bonus, these symbols will be seen as an error if not inside a string
	// FILENAME,       		// i don't think we need this as we will check if something is a file based on the commands we find in our nodes
	// SUBSHELL,       		// we do not need to handle subshell
	// COMMENT,        		// we do not need to handle comments
	// PATH_EXP,			// we do not need this
} t_token_type;

typedef struct s_slice
{
	const char *start; //Pointer to the start of the lexeme. (For 'echo' start is pointing to the 'e')
	size_t length; //Lexeme length.
} t_slice;

typedef struct s_token
{
	t_token_type type;
	t_slice lexeme;
} t_token;

//node selector, like pick one and put it on the node struct (saves memory).
typedef enum e_node_type
{
	//N_ERR = -1, just an idea for now
	N_EXEC,
	N_REDIR,
	N_PIPE
	//N_LIST, //for ; && and ||
	//N_BACK
} t_node_type;


// I think we do not need this one because we have the node struct.
struct s_cmd
{
	t_node_type type;
};

struct s_execcmd
{
	//t_node_type type;
	//char *argv[MAXARGS];
	//char *eargv[MAXARGS];
	//char *cmd;
	char **args;
};


struct s_pipecmd
{
	//t_node_type type;
	//t_cmd *left;
	//t_cmd *right;
	t_tree_node *left;
	t_tree_node *right;

};

union u_node_value
{
	t_execcmd exec_u;
	t_redircmd redir_u;
	t_pipecmd pipe_u;
};

struct s_tree_node
{
	t_node_type type;
	u_node_value data;
};



/* typedef struct s_listcmd
{
	t_node_type type;
	t_cmd *left;
	t_cmd *right;
} t_listcmd;

typedef struct s_backcmd
{
	t_node_type type;
	t_cmd *cmd;
} t_backcmd; */





#endif